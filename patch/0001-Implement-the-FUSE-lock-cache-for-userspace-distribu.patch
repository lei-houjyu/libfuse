From 8ae9f331e0da05bfdac5b5ac9ace6a52497115ac Mon Sep 17 00:00:00 2001
From: Haoyu Li <haoyu.li@columbia.edu>
Date: Mon, 30 Oct 2023 00:33:04 -0600
Subject: [PATCH] Implement the FUSE lock cache for userspace distributed locks

---
 fs/fuse/file.c            | 58 ++++++++++++++++++++++++++++++++++++++-
 fs/fuse/fuse_i.h          | 15 ++++++++++
 fs/fuse/inode.c           | 19 +++++++++++++
 include/uapi/linux/fuse.h |  1 +
 4 files changed, 92 insertions(+), 1 deletion(-)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index c03034e8c152..b4d10605247c 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1252,6 +1252,54 @@ static ssize_t fuse_perform_write(struct kiocb *iocb,
 	return res > 0 ? res : err;
 }
 
+struct fuse_user_lock* fuse_get_lock_from_cache(unsigned long ino) {
+	struct fuse_user_lock* lock = NULL;
+
+	hash_for_each_possible_rcu(fuse_lock_cache, lock, hnode, ino) {
+		if (lock->ino == ino) {
+			break;
+		}
+	}
+
+	return lock;
+}
+
+static struct fuse_user_lock* fuse_get_lock_from_userspace(struct inode* inode) {
+	struct fuse_mount* fm = get_fuse_mount(inode);
+
+	FUSE_ARGS(args);
+	args.opcode = FUSE_USER_LOCK;
+	args.nodeid = inode->i_ino;
+
+	if (!fuse_simple_request(fm, &args)) {
+		pr_err("Failed to get lock from userspace %lu\n", args.nodeid);
+	}
+	
+	struct fuse_user_lock* lock = kmalloc(sizeof(struct fuse_user_lock), GFP_KERNEL);
+	if (!lock) {
+		pr_err("Failed to allocate memory\n");
+		// Next write request to this inode will still send fuse req to the userspace
+		return NULL;
+	}
+
+	lock->ino = inode->i_ino;
+	
+	// TODO: ensure that only one writer is doing this
+	hash_add_rcu(fuse_lock_cache, &lock->hnode, inode->i_ino);
+
+	return lock;
+}
+
+static struct fuse_user_lock* fuse_get_dist_lock(struct inode* inode) {
+	struct fuse_user_lock* lock = fuse_get_lock_from_cache(inode->i_ino);
+	
+	if (lock == NULL || lock->ino != inode->i_ino) {
+		lock = fuse_get_lock_from_userspace(inode);
+	}
+
+	return lock;
+}
+
 static ssize_t fuse_cache_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *file = iocb->ki_filp;
@@ -1268,7 +1316,15 @@ static ssize_t fuse_cache_write_iter(struct kiocb *iocb, struct iov_iter *from)
 		if (err)
 			return err;
 
-		return generic_file_write_iter(iocb, from);
+		rcu_read_lock();
+
+		struct fuse_user_lock* lock = fuse_get_dist_lock(inode->i_ino);
+
+		written = generic_file_write_iter(iocb, from);
+
+		rcu_read_unlock();
+
+		return written;
 	}
 
 	inode_lock(inode);
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d51598017d13..dfedc70f0a20 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -31,6 +31,8 @@
 #include <linux/pid_namespace.h>
 #include <linux/refcount.h>
 #include <linux/user_namespace.h>
+#include <linux/hashtable.h>
+#include <linux/rcupdate.h>
 
 /** Default max number of pages that can be used in a single read request */
 #define FUSE_DEFAULT_MAX_PAGES_PER_REQ 32
@@ -47,6 +49,11 @@
 /** Number of dentries for each connection in the control filesystem */
 #define FUSE_CTL_NUM_DENTRIES 5
 
+#define FUSE_LOCK_CACHE_SIZE 10
+
+/** The lock cache for user-space distributed inode lock */
+extern struct hlist_head fuse_lock_cache[1 << FUSE_LOCK_CACHE_SIZE];
+
 /** List of active connections */
 extern struct list_head fuse_conn_list;
 
@@ -57,6 +64,12 @@ extern struct mutex fuse_mutex;
 extern unsigned max_user_bgreq;
 extern unsigned max_user_congthresh;
 
+/* Distributed locks managed in user space */
+struct fuse_user_lock {
+	unsigned long ino;
+	struct hlist_node hnode;
+};
+
 /* One forget request */
 struct fuse_forget_link {
 	struct fuse_forget_one forget_one;
@@ -1194,6 +1207,8 @@ unsigned int fuse_len_args(unsigned int numargs, struct fuse_arg *args);
 u64 fuse_get_unique(struct fuse_iqueue *fiq);
 void fuse_free_conn(struct fuse_conn *fc);
 
+struct fuse_user_lock* fuse_get_lock_from_cache(unsigned long ino);
+
 /* dax.c */
 
 #define FUSE_IS_DAX(inode) (IS_ENABLED(CONFIG_FUSE_DAX) && IS_DAX(inode))
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 1a47afc95f80..0d88ad2ea76d 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -64,6 +64,8 @@ MODULE_PARM_DESC(max_user_congthresh,
 static struct file_system_type fuseblk_fs_type;
 #endif
 
+DEFINE_HASHTABLE(fuse_lock_cache, FUSE_LOCK_CACHE_SIZE);
+
 struct fuse_forget_link *fuse_alloc_forget(void)
 {
 	return kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL_ACCOUNT);
@@ -395,6 +397,20 @@ int fuse_reverse_inval_inode(struct fuse_conn *fc, u64 nodeid,
 	fi->attr_version = atomic64_inc_return(&fc->attr_version);
 	spin_unlock(&fi->lock);
 
+	// We don't need rcu_read_lock/rcu_read_unlock here 
+	// because no one else will free the lock (external sync?)
+	struct fuse_user_lock* lock = fuse_get_lock_from_cache(inode->i_ino);
+	if (lock) {
+		// Writes happen before this point have the dist lock,
+		// synchroniza_rcu() below will wait for their completion
+		hash_del_rcu(&lock->hnode);
+		// Write requests happen here won't see the lock in the 
+		// hashtable, so they will try to grab the lock from userspace, 
+		// who is responsible for handling such cases
+		synchronize_rcu();
+		kfree(lock);
+	}
+
 	fuse_invalidate_attr(inode);
 	forget_all_cached_acls(inode);
 	if (offset >= 0) {
@@ -1711,6 +1727,8 @@ static int __init fuse_init(void)
 	pr_info("init (API version %i.%i)\n",
 		FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
 
+	hash_init(fuse_lock_cache);
+
 	INIT_LIST_HEAD(&fuse_conn_list);
 	res = fuse_fs_init();
 	if (res)
@@ -1751,6 +1769,7 @@ static void __exit fuse_exit(void)
 	fuse_sysfs_cleanup();
 	fuse_fs_cleanup();
 	fuse_dev_cleanup();
+	//TODO: destroy fuse_lock_cache
 }
 
 module_init(fuse_init);
diff --git a/include/uapi/linux/fuse.h b/include/uapi/linux/fuse.h
index 7233502ea991..c667d2e3cf29 100644
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@ -479,6 +479,7 @@ enum fuse_opcode {
 	FUSE_COPY_FILE_RANGE	= 47,
 	FUSE_SETUPMAPPING	= 48,
 	FUSE_REMOVEMAPPING	= 49,
+	FUSE_USER_LOCK  = 1024,
 
 	/* CUSE specific operations */
 	CUSE_INIT		= 4096,
-- 
2.25.1

